import argparse
import pymeshlab
import math
import logging


def quadrangulate_surface(mesh: str, destination: str, resolution: int) -> None:
    ms = pymeshlab.MeshSet()
    ms.load_new_mesh(mesh)

    # 获取原始面数
    original_face_count = ms.current_mesh().face_number()

    # 计算目标面数（原来的 1/10）
    target_count = max(1, original_face_count // 100)  # 防止为0

    # 网格简化
    ms.meshing_decimation_quadric_edge_collapse(
        targetfacenum=target_count,
        qualitythr=1.0
    )

    # 修复 & 转四边形
    ms.meshing_repair_non_manifold_edges()
    ms.meshing_tri_to_quad_by_smart_triangle_pairing()

    # 保存为临时文件以导出四边形拓扑
    ms.save_current_mesh(
        destination,
        save_vertex_color=False,  # 不保存顶点颜色
        save_vertex_normal=True,  # 保存顶点法线
        save_wedge_texcoord=False,  # 不保存纹理坐标
        save_face_color=False  # 不保存面颜色
    )
    logging.info(f'Quadrangulated mesh to {destination} (reduced to 1/100 faces: {target_count})')

    # 手动访问四边形网格数据
    vertices = []
    normals = []
    quads = []
    with open(destination, 'r') as f:
        for line in f:
            if line.startswith('v '):  # 顶点坐标
                parts = line.strip().split()
                vertex = list(map(float, parts[1:4]))
                vertices.append(vertex)
            elif line.startswith('vn '):  # 顶点法线
                parts = line.strip().split()
                normal = list(map(float, parts[1:4]))
                normals.append(normal)
            elif line.startswith('f '):  # 面
                parts = line.strip().split()[1:]
                if len(parts) != 4:
                    logging.error(f'Unexpected format: {line}')
                    continue

                vert_indices = []
                norm_indices = []
                for part in parts:
                    # 处理 f v//vn 格式
                    if '//' in part:
                        v_idx, n_idx = part.split('//')
                        vert_indices.append(int(v_idx) - 1)
                        norm_indices.append(int(n_idx) - 1)

                quads.append((vert_indices, norm_indices))

    # 构建 UV atlas：为每个四边形分配一个 cols x rows 网格中的方格
    n_quads = len(quads)
    if n_quads == 0:
        logging.warning('未找到可写入的四边形。')
        return

    # 每个 tile 的大小（像素大小）
    grid = max(1, int(math.ceil(math.sqrt(n_quads))))
    tile_size = resolution // grid

    # 覆盖写入临时文件
    with open(destination, 'w') as f:
        f.write("####\n")
        f.write("#\n")
        f.write("# OBJ file generated by NTF (quad UV tiled atlas)\n")
        f.write("#\n")
        f.write("####\n")

        vertex_counter = 0
        for q_idx, quad in enumerate(quads):
            v_idx, n_idx = quad

            # 为当前四边形分配 tile
            c = q_idx % grid  # 当前列
            r = q_idx // grid  # 当前行
            u0 = c * tile_size
            v0 = r * tile_size
            u1 = (c + 1) * tile_size - 1
            v1 = (r + 1) * tile_size - 1

            # 四边形顶点的 UV 坐标（OBJ 底部左下为原点）
            quad_uvs = [(u0, v0), (u1, v0), (u1, v1), (u0, v1)]

            for k, (vi, ni) in enumerate(zip(v_idx, n_idx)):
                v = vertices[vi]
                uv = quad_uvs[k]
                n = normals[ni] if not None else [0.0, 0.0, 1.0]

                # 写入顶点坐标、纹理坐标、法线
                f.write(f"v {v[0]} {v[1]} {v[2]}\n")
                f.write(f"vt {uv[0]} {uv[1]}\n")
                f.write(f"vn {n[0]} {n[1]} {n[2]}\n")

            # 写入面信息，顶点索引从 1 开始
            f.write(
                f"f {vertex_counter + 1}/{vertex_counter + 1}/{vertex_counter + 1} "
                f"{vertex_counter + 2}/{vertex_counter + 2}/{vertex_counter + 2} "
                f"{vertex_counter + 3}/{vertex_counter + 3}/{vertex_counter + 3} "
                f"{vertex_counter + 4}/{vertex_counter + 4}/{vertex_counter + 4}\n"
            )
            vertex_counter += 4

        f.write("# End of File\n")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Quadrangulate a mesh to 1/100 of its original face count.')
    parser.add_argument('--input_mesh', type=str, default='../../assets/models/Icosphere.obj',
                        help='Path to the input mesh file.')
    parser.add_argument('--output_mesh', type=str, default='../../assets/models/Icosphere_baked.obj',
                        help='Path to save the quadrangulated mesh file.')
    parser.add_argument('--resolution', type=int, default=1024,
                        help='Texture resolution used during mesh preprocessing.')

    args = parser.parse_args()

    quadrangulate_surface(args.input_mesh, args.output_mesh, args.resolution)
